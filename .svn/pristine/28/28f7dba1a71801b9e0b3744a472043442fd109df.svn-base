package repository.module

import java.util.Date

import com.google.inject.Inject
import constants.{BaseConstants, DBConstants}
import data.model.Tables.{Fcaipt, FcaiptRow, Fcamct, FcamctRow, FcctmtRow, FcdrdRow, FcdsdRow, FcostmRow, Fcramt, FcramtRow, Fcremt, Fcsft, Fcsmt, FcsmtRow, Fcsopt, FcsoptRow, Fcsraa}
import org.slf4j.LoggerFactory
import play.api.Logger
import play.api.db.slick.{DatabaseConfigProvider, HasDatabaseConfigProvider}
import repository.tables._
import slick.jdbc.JdbcProfile
import utils.DateTimeUtils

import scala.collection.mutable.ListBuffer
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future

/**
  * Created by fincash on 01-02-2017.
  */
class SchemeRepository @Inject()(protected val dbConfigProvider: DatabaseConfigProvider, fcsmtRepo: FcsmtRepo,
                                 fcsoptRepo: FcsoptRepo, fcctmtRepo: FcctmtRepo, fcamctRepo: FcamctRepo,
                                 fcdsdRepo: FcdsdRepo, fcdrdRepo: FcdrdRepo, fcremtRepo: FcremtRepo,
                                 fcsraRepo: FcsraRepo, fcsftRepo: FcsftRepo, fcaiptRepo: FcaiptRepo,fcostmRepo: FcostmRepo)
  extends HasDatabaseConfigProvider[JdbcProfile] with DBConstants with BaseConstants {

  val logger, log = LoggerFactory.getLogger(classOf[SchemeRepository])


  import profile.api._

  def getSchemePrice(soptrfnum: Long, date: Date): Future[Option[BigDecimal]] = {

    val transactionDate = DateTimeUtils.convertDateToYYYYMMDD(date)
    val query = sql"""SELECT
                            PRMTOPENPRICE
                        FROM
                            FCPRMT
                        WHERE
                            PRMTRFNUM IN (SELECT
                                    PPAPRMTRFNUM
                                FROM
                                    FCPPA
                                WHERE
                                    PPASOPTRFNUM = ${soptrfnum})
                                AND DATE(PRMTDATE) = DATE(${transactionDate})""".as[BigDecimal]
    db.run(query).map(value => value.headOption)
  }

  def getSchemeById(id: Long): Future[FcsmtRow] = {
    fcsmtRepo.getById(id).map(_.head)
  }

  def getSchemeOptionById(id: Long): Future[FcsoptRow] = {
    fcsoptRepo.getById(id).map(_.head)
  }

  def getDefaultSchemeById(id: Long): Future[FcsoptRow] = {
    fcsoptRepo.filter(soptObj => soptObj.soptsmtrfnum === id && soptObj.soptisdefault === Y_FLAG).map(_.head)
  }

  def getSchemeCategoryById(id: Long): Future[FcctmtRow] = {
    fcctmtRepo.getById(id).map(_.head)
  }


  def getSchemeAMCById(id: Long): Future[FcamctRow] = {
    fcamctRepo.getById(id).map(_.head)
  }

  def getDailySchemeData(soptId: Long): Future[Option[FcdsdRow]] = {
    fcdsdRepo.filter(x => x.dsdsoptrfnum === soptId).map(x => {
      if(x.isEmpty){
        None
      } else{

        Some(x.head)
      }
    })
  }

  def getDailyReturnData(soptId: Long): Future[Seq[FcdrdRow]] = {
    fcdrdRepo.filter(x => x.drdsoptrfnum === soptId)
  }

  def getLatestRatioData(soptId: Long): Future[FcramtRow] = {
    val query = for {
      fcsraaObj <- Fcsraa.filter(x => x.sraasoptrfnum === soptId).sortBy(_.createdate desc).take(1)
      fcramtObj <- Fcramt.filter(ramt => ramt.id === fcsraaObj.sraaramtrfnum)
    } yield (fcramtObj)

    db.run(query.result.transactionally).map(_.head).recover {
      case ex: Exception => {
        logger.debug("Scheme option id is:##################" + soptId);
        throw ex
      };
    }

  }

  def getMinSIPAmount(soptId: Long): Future[Option[Int]] = {
    val query = for {
      fcaiptObj <- Fcaipt.filter(x => x.aiptsoptrfnum === soptId).groupBy(x => x.aiptsoptrfnum).map {
        case (aiptminamount, group) => (aiptminamount, group.map(_.aiptminamount).min)
      }
    } yield (fcaiptObj)

    db.run(query.result.transactionally).map(data => {
      if (data.length > 0) {
        data.head._2
      } else {
        None
      }
    }).recover {
      case ex: Exception => throw ex;
    }

  }

  def getSchemeLastReturn(remtperiodunit: String, remtperiodvalue: Int, soptrfnum: Long): Future[Option[Float]] = {

    getReturnIds(soptrfnum).flatMap(values => {
      val query = Fcremt.filter(x => (x.remtperiodunit === remtperiodunit) && (x.remtperiodvalue === remtperiodvalue) &&
        (x.id inSetBind (values))).sortBy(_.remtreturnasofdate desc).map(_.remtreturn).result
      db.run(query).map(returnList => {
        returnList.head
      })
    })
  }

  def getReturnIds(soptrfnum: Long): Future[List[Long]] = {
    fcsraRepo.filter(x => x.srasoptrfnum === soptrfnum).map(values => {
      val remtIdList: ListBuffer[Long] = ListBuffer[Long]()
      values.foreach(value => {
        remtIdList.+=(value.id)
      })
      remtIdList.toList
    })
  }

  def getSipSchemes(smtrfnum: Long, soptSipSchemeIds: List[Long]): Future[ListBuffer[FcsoptRow]] = {

    val sipSchemeIds = soptSipSchemeIds.mkString(",")
    val query = sql"""SELECT
                            *
                        FROM
                            FCSOPT
                        WHERE
                            SOPTSMTRFNUM = ${smtrfnum} AND SOPTRFNUM in (#${sipSchemeIds})
                        ORDER BY FIELD(SOPTSCHEMEPLAN, ${GROWTH_FUND}, ${DIVIDEND_FUND}) ,
                        FIELD(SOPTDIVIOPTIONTYPE, ${PAYOUT}, ${REINVESTMENT_DIVIDEND}) , FIELD(SOPTDIVIDENDFRQN,
                                ${NORMAL},${DAY},${WEEK},${FORTNIGHTLY},${MONTH},${QUATERLY},
                                ${HALFYEARLY},${YEAR})""".as[FcsoptRow]

    db.run(query).map(values => {
      val schemeOptionList = ListBuffer[FcsoptRow]()

      values.foreach(soptRow => {

        schemeOptionList.+=(soptRow)
      })
      schemeOptionList
    })
  }

  def getSipSchemePlanOptions(smtrfnum: Long, soptSipSchemeIds: List[Long], schemePlanType: String, divFreq: String) = {
    val sipSchemeIds = soptSipSchemeIds.mkString(",")
    val query = sql"""SELECT
                            *
                        FROM
                            FCSOPT
                        WHERE
                            SOPTSMTRFNUM = ${smtrfnum} AND SOPTRFNUM in (#${sipSchemeIds})
                        AND SOPTSCHEMEPLAN = ${schemePlanType} AND SOPTDIVIDENDFRQN = ${divFreq}
                        ORDER BY FIELD(SOPTSCHEMEPLAN, ${GROWTH_FUND}, ${DIVIDEND_FUND}) ,
                        FIELD(SOPTDIVIOPTIONTYPE, ${PAYOUT}, ${REINVESTMENT_DIVIDEND}) , FIELD(SOPTDIVIDENDFRQN,
                                ${NORMAL},${DAY},${WEEK},${FORTNIGHTLY},${MONTH},${QUATERLY},
                                ${HALFYEARLY},${YEAR})""".as[FcsoptRow]

    db.run(query).map(values => {
      val schemeOptionList = ListBuffer[FcsoptRow]()

      values.foreach(soptRow => {

        schemeOptionList.+=(soptRow)
      })
      schemeOptionList
    })
  }

  def getPlanOptionFreq(smtrfnum: Long, schemeplanType: String, divFreqType: String, divOptionType: String): Future[List[FcaiptRow]] = {

    val query = Fcaipt.filter(x => {
      x.aiptsoptrfnum in Fcsopt.filter(x => {
        x.soptsmtrfnum === smtrfnum && x.soptdividendfrqn === divFreqType && x.soptschemeplan === schemeplanType &&
          x.soptdivioptiontype === divOptionType
      }).map(_.id)
    })

    db.run(query.result).map(frequencyList => {
      frequencyList.toList
    })
  }

  def getPlanDetails(smtrfnum: Long): Future[List[FcaiptRow]] = {

    val query = for {
      soptObj <- Fcsopt.filter(_.soptsmtrfnum === smtrfnum).map(_.id).result
      aiptRow <- Fcaipt.filter(_.aiptsoptrfnum inSetBind (soptObj)).result
    } yield (aiptRow)

    db.run(query).map(values => {
      values.toList
    })
  }

  def getSchemeOptionDates(smtrfnum: Long, schemePlan: String, divFreq: String, divOption: String): Future[List[FcaiptRow]] = {

    val query = for {
      aiptObj <- Fcaipt.filter(x => {
        x.aiptsoptrfnum in Fcsopt.filter(x => {
          x.soptschemeplan === schemePlan && x.soptdividendfrqn === divFreq &&
            x.soptdividendfrqn === divFreq && x.soptsmtrfnum === smtrfnum
        }).map(_.id)
      }).result
    } yield (aiptObj)

    db.run(query).map(values => {
      values.toList
    })
  }

  def getSIPFlag(soptrfnum: Long): Future[String] = {
    fcsftRepo.getById(soptrfnum).map(x => {
      if (x.isEmpty) {
        NO
      } else {
        x.get.sftsipflag
      }
    })
  }

  def getSIPSchemePlans(smtrfnum: Long): Future[List[FcsoptRow]] = {

    val query = Fcsopt.filter(_.id in Fcsft.filter(x => (x.id in Fcsopt.filter(_.soptsmtrfnum === smtrfnum).map(_.id)) && (x.sftsipflag === YES)).map(_.id))

    db.run(query.result).map(values => {
      values.toList
    })
  }

  def getSchemeOptions(smtrfnum: Long, schemePlan: String, divFreq: String): Future[List[String]] = {

    val schemeOptionsList = fcsoptRepo.filter(x => (x.soptschemeplan === schemePlan && x.soptdividendfrqn === divFreq && x.soptsmtrfnum === smtrfnum)).map(values => {
      val valuesList = values.toList
      for (value <- valuesList) yield {
        value.soptdivioptiontype
      }
    })
    schemeOptionsList
  }

  def getAllOptionsBySchemeId(id: Long): Future[Seq[FcsoptRow]] = {
    fcsoptRepo.filter(x => x.soptsmtrfnum === id)
  }

  def getAllAIPDataByOptionId(id: Long): Future[List[FcaiptRow]] = {
    fcaiptRepo.filter(x => x.aiptsoptrfnum === id).map(data => data.toList)
  }

  def getSchemeWithAmcDetails(smtrfnum: Long):Future[Seq[(FcsmtRow,FcamctRow)]] = {
    val query = for {
      smtObj <- Fcsmt.filter(_.id === smtrfnum)
      amctObj <- Fcamct.filter(_.id === smtObj.smtamctrfnum)
    }yield(smtObj,amctObj)

    db.run(query.result).map(value => value)
  }

  def getOrderStateName(ostmrfnum:Long):Future[Option[FcostmRow]] = {
    fcostmRepo.getById(ostmrfnum).map(value => value)
  }
}
